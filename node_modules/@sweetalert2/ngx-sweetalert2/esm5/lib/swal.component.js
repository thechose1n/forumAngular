import { __assign, __awaiter, __decorate, __generator, __param } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
var SwalComponent = /** @class */ (function () {
    function SwalComponent(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions
         * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by
         * another popup.
         */
        this.destroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    Object.defineProperty(SwalComponent.prototype, "swalOptions", {
        /**
         * Computes the options object that will get passed to SweetAlert2.
         * Only the properties that have been set at least once on this component will be returned.
         * Mostly for internal usage.
         */
        get: function () {
            var _this = this;
            var options = {};
            //=> We will compute the options object based on the option keys that are known to have changed.
            //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
            //   avoiding side effects.
            this.touchedProps.forEach(function (prop) {
                options[prop] = _this[prop];
            });
            return options;
        },
        /**
         * An object of SweetAlert2 native options, useful if:
         *  - you don't want to use the @Inputs for practical/philosophical reasons ;
         *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
         *
         * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
         *     previous properties you want to erase again.
         *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
         *
         * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
         */
        set: function (options) {
            //=> Update properties
            Object.assign(this, options);
            //=> Mark changed properties as touched
            var touchedKeys = Object.keys(options);
            touchedKeys.forEach(this.markTouched);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwalComponent.prototype, "swalVisible", {
        get: function () {
            return this.isCurrentlyShown;
        },
        set: function (visible) {
            visible ? this.fire() : this.dismiss();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    SwalComponent.prototype.ngOnInit = function () {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    };
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    SwalComponent.prototype.ngAfterViewInit = function () {
        var fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    };
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    SwalComponent.prototype.ngOnChanges = function (changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter(function (prop) { return !prop.startsWith('swal'); })
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    };
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    SwalComponent.prototype.ngOnDestroy = function () {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        var dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    };
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    SwalComponent.prototype.fire = function () {
        return __awaiter(this, void 0, void 0, function () {
            var swal, options, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        options = __assign(__assign({}, this.swalOptions), { 
                            //=> Handle modal lifecycle events
                            onBeforeOpen: function (modalElement) {
                                _this.beforeOpen.emit({ modalElement: modalElement });
                            }, onOpen: function (modalElement) {
                                _this.isCurrentlyShown = true;
                                _this.open.emit({ modalElement: modalElement });
                            }, onRender: function (modalElement) {
                                _this.render.emit({ modalElement: modalElement });
                            }, onClose: function (modalElement) {
                                _this.isCurrentlyShown = false;
                                _this.close.emit({ modalElement: modalElement });
                            }, onAfterClose: function () {
                                _this.afterClose.emit();
                            }, onDestroy: function () {
                                _this.destroy.emit();
                            } });
                        return [4 /*yield*/, swal.fire(options)];
                    case 2:
                        result = _a.sent();
                        //=> Emit on (confirm) or (cancel)
                        if ('value' in result) {
                            this.confirm.emit(result.value);
                        }
                        else {
                            this.cancel.emit(result.dismiss);
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {@link Swal.close}
     */
    SwalComponent.prototype.dismiss = function (result) {
        return __awaiter(this, void 0, void 0, function () {
            var swal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.isCurrentlyShown)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        swal.close(result);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    SwalComponent.prototype.update = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var swal, allOptions, updatableOptions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options) {
                            this.swalOptions = options;
                        }
                        if (!this.isCurrentlyShown)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        allOptions = this.swalOptions;
                        updatableOptions = Object.keys(allOptions)
                            .filter(function (key) { return swal.isUpdatableParameter(key); })
                            .reduce(function (obj, key) {
                            obj[key] = allOptions[key];
                            return obj;
                        }, {});
                        swal.update(updatableOptions);
                        return [2 /*return*/];
                }
            });
        });
    };
    SwalComponent.ctorParameters = function () { return [
        { type: SweetAlert2LoaderService },
        { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
    ]; };
    __decorate([
        Input()
    ], SwalComponent.prototype, "title", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "titleText", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "text", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "html", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "footer", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "icon", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "iconHtml", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "backdrop", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "toast", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "target", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "input", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "width", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "padding", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "background", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "position", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "grow", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "showClass", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "hideClass", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "customClass", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "timer", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "timerProgressBar", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "animation", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "heightAuto", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "allowOutsideClick", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "allowEscapeKey", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "allowEnterKey", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "stopKeydownPropagation", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "keydownListenerCapture", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "showConfirmButton", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "showCancelButton", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "confirmButtonText", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "cancelButtonText", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "confirmButtonColor", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "cancelButtonColor", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "confirmButtonAriaLabel", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "cancelButtonAriaLabel", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "buttonsStyling", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "reverseButtons", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "focusConfirm", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "focusCancel", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "showCloseButton", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "closeButtonHtml", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "closeButtonAriaLabel", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "showLoaderOnConfirm", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "preConfirm", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "imageUrl", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "imageWidth", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "imageHeight", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "imageAlt", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputPlaceholder", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputValue", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputOptions", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputAutoTrim", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputAttributes", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "inputValidator", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "validationMessage", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "progressSteps", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "currentProgressStep", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "progressStepsDistance", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "scrollbarPadding", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "swalOptions", null);
    __decorate([
        Input()
    ], SwalComponent.prototype, "swalFireOnInit", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "swalDismissOnDestroy", void 0);
    __decorate([
        Input()
    ], SwalComponent.prototype, "swalVisible", null);
    __decorate([
        Output()
    ], SwalComponent.prototype, "beforeOpen", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "open", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "render", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "close", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "afterClose", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "destroy", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "confirm", void 0);
    __decorate([
        Output()
    ], SwalComponent.prototype, "cancel", void 0);
    SwalComponent = __decorate([
        Component({
            // tslint:disable-next-line:component-selector
            selector: 'swal',
            template: '',
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __param(1, Inject(fireOnInitToken)),
        __param(2, Inject(dismissOnDestroyToken))
    ], SwalComponent);
    return SwalComponent;
}());
export { SwalComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsibGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBRUgsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFnQyxNQUFNLEVBQ3hHLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFOUQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFeEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFPSDtJQXlOSSx1QkFDcUIsaUJBQTJDLEVBQ2xCLHFCQUE4QixFQUN4QiwyQkFBb0M7UUFGbkUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUEwQjtRQUNsQiwwQkFBcUIsR0FBckIscUJBQXFCLENBQVM7UUFDeEIsZ0NBQTJCLEdBQTNCLDJCQUEyQixDQUFTO1FBNUZ4Rjs7O1dBR0c7UUFFYSxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQTBCLENBQUM7UUFFeEU7O1dBRUc7UUFFYSxTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFFNUQ7O1dBRUc7UUFFYSxXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQXNCLENBQUM7UUFFaEU7OztXQUdHO1FBRWEsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFxQixDQUFDO1FBRTlEOzs7V0FHRztRQUVhLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRXREOzs7OztXQUtHO1FBRWEsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFFbkQ7Ozs7Ozs7Ozs7V0FVRztRQUVhLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBRWxEOzs7Ozs7Ozs7Ozs7V0FZRztRQUVhLFdBQU0sR0FB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QUFFO29EQVFQO0lBNEJEO1FBREMsS0FBSyxFQUFFO3lEQUN3QjtJQU9oQztRQURDLEtBQUssRUFBRTsrREFDOEI7SUFHdEM7UUFEQyxLQUFLLEVBQUU7b0RBR1A7SUFXRDtRQURDLE1BQU0sRUFBRTtxREFDK0Q7SUFNeEU7UUFEQyxNQUFNLEVBQUU7K0NBQ21EO0lBTTVEO1FBREMsTUFBTSxFQUFFO2lEQUN1RDtJQU9oRTtRQURDLE1BQU0sRUFBRTtnREFDcUQ7SUFPOUQ7UUFEQyxNQUFNLEVBQUU7cURBQzZDO0lBU3REO1FBREMsTUFBTSxFQUFFO2tEQUMwQztJQWNuRDtRQURDLE1BQU0sRUFBRTtrREFDeUM7SUFnQmxEO1FBREMsTUFBTSxFQUFFO2lEQUNtRTtJQXRNbkUsYUFBYTtRQU56QixTQUFTLENBQUM7WUFDUCw4Q0FBOEM7WUFDOUMsUUFBUSxFQUFFLE1BQU07WUFDaEIsUUFBUSxFQUFFLEVBQUU7WUFDWixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtTQUNsRCxDQUFDO1FBNE5PLFdBQUEsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFBO1FBQ3ZCLFdBQUEsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUE7T0E1TnpCLGFBQWEsQ0E4V3pCO0lBQUQsb0JBQUM7Q0FBQSxBQTlXRCxJQThXQztTQTlXWSxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRSZXN1bHQgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBkaXNtaXNzT25EZXN0cm95VG9rZW4sIGZpcmVPbkluaXRUb2tlbiB9IGZyb20gJy4vZGknO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc3dhbC1ldmVudHMnO1xuaW1wb3J0IHsgU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi9zd2VldGFsZXJ0Mi1sb2FkZXIuc2VydmljZSc7XG5cbi8qKlxuICogPHN3YWw+IGNvbXBvbmVudC4gU2VlIHRoZSBSRUFETUUubWQgZm9yIHVzYWdlLlxuICpcbiAqIEl0IGNvbnRhaW5zIGEgYnVuY2ggb2YgQElucHV0cyB0aGF0IGhhdmUgYSBwZXJmZWN0IDE6MSBtYXBwaW5nIHdpdGggU3dlZXRBbGVydDIgb3B0aW9ucy5cbiAqIFRoZWlyIHR5cGVzIGFyZSBkaXJlY3RseSBjb21pbmcgZnJvbSBTd2VldEFsZXJ0MiB0eXBlcyBkZWZpbnRpdGlvbnMsIG1lYW5pbmcgdGhhdCBuZ3gtc3dlZXRhbGVydDIgaXMgdGlnaHRseSBjb3VwbGVkXG4gKiB0byBTd2VldEFsZXJ0MiwgYnV0IGFsc28gaXMgdHlwZS1zYWZlLlxuICpcbiAqICg/KSBJZiB5b3Ugd2FudCB0byB1c2UgYW4gb2JqZWN0IHRoYXQgZGVjbGFyZXMgdGhlIFN3ZWV0QWxlcnQyIG9wdGlvbnMgYWxsIGF0IG9uY2UgcmF0aGVyIHRoYW4gbWFueSBASW5wdXRzLFxuICogICAgIHRha2UgYSBsb29rIGF0IFtzd2FsT3B0aW9uc10sIHRoYXQgbGV0cyB5b3UgcGFzcyBhIGZ1bGwge0BsaW5rIFN3ZWV0QWxlcnRPcHRpb25zfSBvYmplY3QuXG4gKlxuICogKD8pIElmIHlvdSBhcmUgcmVhZGluZyB0aGUgVHlwZVNjcmlwdCBzb3VyY2Ugb2YgdGhpcyBjb21wb25lbnQsIHlvdSBtYXkgdGhpbmsgdGhhdCBpdCdzIGEgbG90IG9mIGNvZGUuXG4gKiAgICAgQmUgc3VyZSB0aGF0IGEgbG90IG9mIHRoaXMgY29kZSBpcyB0eXBlcyBhbmQgQW5ndWxhciBib2lsZXJwbGF0ZS4gQ29tcGlsZWQgYW5kIG1pbmlmaWVkIGNvZGUgaXMgbXVjaCBzbWFsbGVyLlxuICogICAgIElmIHlvdSBhcmUgcmVhbGx5IGNvbmNlcm5lZCBhYm91dCBwZXJmb3JtYW5jZSBhbmQvb3IgZG9uJ3QgY2FyZSBhYm91dCB0aGUgQVBJIGFuZCBpdHMgY29udmVuaWVudCBpbnRlZ3JhdGlvblxuICogICAgIHdpdGggQW5ndWxhciAobm90YWJseSBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCB0cmFuc2NsdXNpb24pLCB5b3UgbWF5IHRvdGFsbHkgdXNlIFN3ZWV0QWxlcnQyIG5hdGl2ZWx5IGFzIHdlbGwgOylcbiAqXG4gKiAvIVxcIFNvbWUgU3dlZXRBbGVydCBvcHRpb25zIGFyZW4ndCBASW5wdXRzIGJ1dCBAT3V0cHV0czogb25CZWZvcmVPcGVuLCBvbk9wZW4sIG9uQ2xvc2UsIG9uQWZ0ZXJDbG9zZSBhbmQgb25EZXN0cm95XG4gKiAgICAgKGJ1dCB3aXRob3V0IFwib24qXCIgcHJlZml4IHRvIHJlc3BlY3QgY29tbXVuaXR5IHN0YW5kYXJkcykuXG4gKiAgICAgSG93ZXZlciwgcHJlQ29uZmlybSBhbmQgaW5wdXRWYWxpZGF0b3IgYXJlIHN0aWxsIEBJbnB1dHMgYmVjYXVzZSB0aGVyZSBhcmUgbm90IGV2ZW50IGhhbmRsZXJzLCB0aGVyZSBjYW4ndCBiZVxuICogICAgIG11bHRpcGxlIGxpc3RlbmVycyBhbmQgd2UgbmVlZCB0aGUgdmFsdWVzIHRoZXkgY2FuL211c3QgcmV0dXJuLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gICAgc2VsZWN0b3I6ICdzd2FsJyxcbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3dhbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZTogU3dlZXRBbGVydE9wdGlvbnNbJ3RpdGxlJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpdGxlVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RpdGxlVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0ZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBodG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snaHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb290ZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydmb290ZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaWNvbjogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaWNvbkh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uSHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZHJvcDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ107XG4gICAgQElucHV0KCkgcHVibGljIHRvYXN0OiBTd2VldEFsZXJ0T3B0aW9uc1sndG9hc3QnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGFyZ2V0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGFyZ2V0J107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgd2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWyd3aWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwYWRkaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1sncGFkZGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZ3JvdW5kOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2dyb3VuZCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwb3NpdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Bvc2l0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGdyb3c6IFN3ZWV0QWxlcnRPcHRpb25zWydncm93J107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoaWRlQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydoaWRlQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VzdG9tQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXN0b21DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aW1lcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyUHJvZ3Jlc3NCYXI6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aW1lclByb2dyZXNzQmFyJ107XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBzaG93Q2xhc3MgYW5kIGhpZGVDbGFzcyBpbnN0ZWFkICovXG4gICAgQElucHV0KCkgcHVibGljIGFuaW1hdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ2FuaW1hdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoZWlnaHRBdXRvOiBTd2VldEFsZXJ0T3B0aW9uc1snaGVpZ2h0QXV0byddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd091dHNpZGVDbGljazogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93T3V0c2lkZUNsaWNrJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RXNjYXBlS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFc2NhcGVLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFbnRlcktleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RW50ZXJLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc3RvcEtleWRvd25Qcm9wYWdhdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3N0b3BLZXlkb3duUHJvcGFnYXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMga2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTogU3dlZXRBbGVydE9wdGlvbnNbJ2tleWRvd25MaXN0ZW5lckNhcHR1cmUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NvbmZpcm1CdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q29uZmlybUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2FuY2VsQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NhbmNlbEJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBidXR0b25zU3R5bGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ2J1dHRvbnNTdHlsaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIHJldmVyc2VCdXR0b25zOiBTd2VldEFsZXJ0T3B0aW9uc1sncmV2ZXJzZUJ1dHRvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ2FuY2VsOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDYW5jZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0Nsb3NlQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0Nsb3NlQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2Nsb3NlQnV0dG9uSHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2Nsb3NlQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dMb2FkZXJPbkNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93TG9hZGVyT25Db25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIHByZUNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydwcmVDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlVXJsOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VVcmwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VXaWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlV2lkdGgnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VIZWlnaHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUhlaWdodCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUFsdDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlQWx0J107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0UGxhY2Vob2xkZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFBsYWNlaG9sZGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsdWU6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0T3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0T3B0aW9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF1dG9UcmltOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdXRvVHJpbSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF0dHJpYnV0ZXM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWxpZGF0b3I6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbGlkYXRvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB2YWxpZGF0aW9uTWVzc2FnZTogU3dlZXRBbGVydE9wdGlvbnNbJ3ZhbGlkYXRpb25NZXNzYWdlJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHM6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXJyZW50UHJvZ3Jlc3NTdGVwJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHNEaXN0YW5jZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzY3JvbGxiYXJQYWRkaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1snc2Nyb2xsYmFyUGFkZGluZyddO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IG9mIFN3ZWV0QWxlcnQyIG5hdGl2ZSBvcHRpb25zLCB1c2VmdWwgaWY6XG4gICAgICogIC0geW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZSBASW5wdXRzIGZvciBwcmFjdGljYWwvcGhpbG9zb3BoaWNhbCByZWFzb25zIDtcbiAgICAgKiAgLSB0aGVyZSBhcmUgbWlzc2luZyBASW5wdXRzIGJlY2F1c2Ugbmd4LXN3ZWV0YWxlcnQyIGlzbid0IHVwLXRvLWRhdGUgd2l0aCBTd2VldEFsZXJ0MidzIGxhdGVzdCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogLyFcXCBQbGVhc2Ugbm90ZSB0aGF0IHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkb2VzIE5PVCBlcmFzZSB3aGF0IGhhcyBiZWVuIHNldCBiZWZvcmUgdW5sZXNzIHlvdSBzcGVjaWZ5IHRoZVxuICAgICAqICAgICBwcmV2aW91cyBwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIGVyYXNlIGFnYWluLlxuICAgICAqICAgICBJZS4gc2V0dGluZyB7IHRpdGxlOiAnVGl0bGUnIH0gYW5kIHRoZW4geyB0ZXh0OiAnVGV4dCcgfSB3aWxsIGdpdmUgeyB0aXRsZTogJ1RpdGxlJywgdGV4dDogJ1RleHQnIH0uXG4gICAgICpcbiAgICAgKiAvIVxcIEJlIGF3YXJlIHRoYXQgdGhlIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCB3aWxsIG92ZXJyaWRlIHRoZSBASW5wdXRzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN3YWxPcHRpb25zKG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zKSB7XG4gICAgICAgIC8vPT4gVXBkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLz0+IE1hcmsgY2hhbmdlZCBwcm9wZXJ0aWVzIGFzIHRvdWNoZWRcbiAgICAgICAgY29uc3QgdG91Y2hlZEtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSBhcyBBcnJheTxrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucz47XG4gICAgICAgIHRvdWNoZWRLZXlzLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG9wdGlvbnMgb2JqZWN0IHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIFN3ZWV0QWxlcnQyLlxuICAgICAqIE9ubHkgdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gc2V0IGF0IGxlYXN0IG9uY2Ugb24gdGhpcyBjb21wb25lbnQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBNb3N0bHkgZm9yIGludGVybmFsIHVzYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3dhbE9wdGlvbnMoKTogU3dlZXRBbGVydE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvcHRpb25zOiB7IFtQIGluIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zXTogYW55IH0gPSB7fTtcblxuICAgICAgICAvLz0+IFdlIHdpbGwgY29tcHV0ZSB0aGUgb3B0aW9ucyBvYmplY3QgYmFzZWQgb24gdGhlIG9wdGlvbiBrZXlzIHRoYXQgYXJlIGtub3duIHRvIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgLy8gICBUaGF0IGF2b2lkcyBwYXNzaW5nIGEgZ2lnYW50aWMgb2JqZWN0IHRvIFN3ZWV0QWxlcnQyLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBhbmQgcG90ZW50aWFsbHlcbiAgICAgICAgLy8gICBhdm9pZGluZyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHRoaXMudG91Y2hlZFByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BdID0gdGhpc1twcm9wIGFzIGtleW9mIHRoaXNdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGZpcmUgdGhlIG1vZGFsIGFzIHNvb24gYXMgdGhlIDxzd2FsPiBjb21wb25lbnQgaXMgY3JlYXRlZCBhbmQgaW5pdGlhbGl6ZWQgaW4gdGhlIHZpZXcuXG4gICAgICogV2hlbiBsZWZ0IHVuZGVmaW5lZCAoZGVmYXVsdCksIHRoZSB2YWx1ZSB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBtb2R1bGUgY29uZmlndXJhdGlvbiwgd2hpY2ggaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsICpuZ0lmPVwiZXJyb3JcIiBbdGl0bGVdPVwiZXJyb3IudGl0bGVcIiBbdGV4dF09XCJlcnJvci50ZXh0XCIgaWNvbj1cImVycm9yXCIgW3N3YWxGaXJlT25Jbml0XT1cInRydWVcIj48L3N3YWw+XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbEZpcmVPbkluaXQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkaXNtaXNzIHRoZSBtb2RhbCB3aGVuIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGRlc3Ryb3llZCBieSBBbmd1bGFyIChmb3IgYW55IHJlYXNvbikgb3Igbm90LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2FsRGlzbWlzc09uRGVzdHJveT86IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbFZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB2aXNpYmxlID8gdGhpcy5maXJlKCkgOiB0aGlzLmRpc21pc3MoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN3YWxWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRseVNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIERPTSBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogVXNlZnVsIHRvIHBlcmZvcm0gRE9NIG11dGF0aW9ucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBiZWZvcmVPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuQmVmb3JlT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgaXMgc2hvd24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IG9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5PcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBET00gaXMgcmVuZGVyZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHJlbmRlciA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLlJlbmRlckV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgd2lsbCBiZSBjbG9zZWQuXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBrbm93IHdoZW4gdGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbCwgcHJlZmVyIHRoZSBoaWdoZXItbGV2ZWwgKGNhbmNlbCkgb3V0cHV0LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkNsb3NlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgbW9kYWwgaGFkIGJlZW4gY2xvc2VkLlxuICAgICAqIElmIHlvdSBqdXN0IHdhbnQgdG8ga25vdyB3aGVuIHRoZSB1c2VyIGRpc21pc3NlZCB0aGUgbW9kYWwsIHByZWZlciB0aGUgaGlnaGVyLWxldmVsIChjYW5jZWwpIG91dHB1dC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgYWZ0ZXJDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBtb2RhbCBoYWQgYmVlbiBjbG9zZWQuXG4gICAgICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB7QGxpbmsgZGVzdHJveX0gYW5kIHtAbGluayBhZnRlckNsb3NlfSBpcyB0aGF0IHRoZSBsYXR0ZXIgaXMgY2FsbGVkIGZvciB1c2VyIGludGVyYWN0aW9uc1xuICAgICAqIG9ubHkgKGNsaWNrcyksIHdoZXJlYXMge0BsaW5rIGRlc3Ryb3l9IGlzIGFsd2F5cyBjYWxsZWQsIGJvdGggZm9yIHVzZXIgaW50ZXJhY3Rpb25zIGFuZCBwb3B1cCBiZWluZyBjbG9zZWQgYnlcbiAgICAgKiBhbm90aGVyIHBvcHVwLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjb25maXJtKT1cImhhbmRsZUNvbmZpcm0oJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlQ29uZmlybShlbWFpbDogc3RyaW5nKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyAuLi4gc2F2ZSB1c2VyIGVtYWlsXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiwgb3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgYWxsb3dlZCB3YXkuXG4gICAgICogQnkgZGVmYXVsdCwgaXQgd2lsbCBlbWl0IGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVhc29uIGZvciB3aGljaCB0aGUgU3dlZXRBbGVydCBoYXMgYmVlbiBjbG9zZWQuXG4gICAgICogVGhlIHJlYXNvbiBpcyBgdW5kZWZpbmVkYCB3aGVuIHtAbGluayBkaXNtaXNzfSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY2FuY2VsKT1cImhhbmRsZUNhbmNlbCgkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDYW5jZWwocmVhc29uOiBEaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyByZWFzb24gY2FuIGJlICdjYW5jZWwnLCAnb3ZlcmxheScsICdjbG9zZScsICd0aW1lcicgb3IgdW5kZWZpbmVkLlxuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8U3dhbC5EaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBTZXQgcmV0YWlucyB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBjaGFuZ2VkIGZyb20gQElucHV0cywgc28gd2UgY2FuIGtub3cgcHJlY2lzZWx5XG4gICAgICogd2hhdCBvcHRpb25zIHdlIGhhdmUgdG8gc2VuZCB0byB7QGxpbmsgU3dhbC5maXJlfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvdWNoZWRQcm9wcyA9IG5ldyBTZXQ8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIG9mIHNpZ25hdHVyZSBgKHByb3BOYW1lOiBzdHJpbmcpOiB2b2lkYCB0aGF0IGFkZHMgYSBnaXZlbiBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBsaXN0IG9mXG4gICAgICogdG91Y2hlZCBwcm9wZXJ0aWVzLCBpZS4ge0BsaW5rIHRvdWNoZWRQcm9wc30uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXJrVG91Y2hlZCA9IHRoaXMudG91Y2hlZFByb3BzLmFkZC5iaW5kKHRoaXMudG91Y2hlZFByb3BzKTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBTd2VldEFsZXJ0MiBtb2RhbCByZXByZXNlbnRlZCBieSB0aGlzIGNvbXBvbmVudCBjdXJyZW50bHkgb3BlbmVkP1xuICAgICAqL1xuICAgIHByaXZhdGUgaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHN3ZWV0QWxlcnQyTG9hZGVyOiBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoZmlyZU9uSW5pdFRva2VuKSBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZUxldmVsRmlyZU9uSW5pdDogYm9vbGVhbixcbiAgICAgICAgQEluamVjdChkaXNtaXNzT25EZXN0cm95VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95OiBib29sZWFuKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBBc2tzIHRoZSBTd2VldEFsZXJ0MiBsb2FkZXIgc2VydmljZSB0byBwcmVsb2FkIHRoZSBTd2VldEFsZXJ0MiBsaWJyYXJ5LCBzbyBpdCBiZWdpbnMgdG8gYmUgbG9hZGVkIG9ubHkgaWYgdGhlcmVcbiAgICAgKiBpcyBhIDxzd2FsPiBjb21wb25lbnQgc29tZXdoZXJlLCBhbmQgaXMgcHJvYmFibHkgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIG1vZGFsIGhhcyB0byBiZSBkaXNwbGF5ZWQsXG4gICAgICogY2F1c2luZyBubyBkZWxheS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUHJlbG9hZCBTd2VldEFsZXJ0MiBsaWJyYXJ5IGluIGNhc2UgdGhpcyBjb21wb25lbnQgaXMgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnByZWxvYWRTd2VldEFsZXJ0TGlicmFyeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogRmlyZXMgdGhlIG1vZGFsLCBpZiB0aGUgY29tcG9uZW50IG9yIG1vZHVsZSBpcyBjb25maWd1cmVkIHRvIGRvIHNvLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpcmVPbkluaXQgPSB0aGlzLnN3YWxGaXJlT25Jbml0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbEZpcmVPbkluaXRcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRmlyZU9uSW5pdDtcblxuICAgICAgICBmaXJlT25Jbml0ICYmIHRoaXMuZmlyZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogVXBkYXRlcyB0aGUgU3dlZXRBbGVydCBvcHRpb25zLCBhbmQgaWYgdGhlIG1vZGFsIGlzIG9wZW5lZCwgYXNrcyBTd2VldEFsZXJ0IHRvIHJlbmRlciBpdCBhZ2Fpbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICAvLz0+IEZvciBlYWNoIGNoYW5nZWQgQElucHV0IHRoYXQgbWF0Y2hlcyBhIFN3ZWV0QWxlcnQyIG9wdGlvbiwgbWFyayBhcyB0b3VjaGVkIHNvIHdlIGNhblxuICAgICAgICAvLyAgIHNlbmQgaXQgd2l0aCB0aGUgbmV4dCBmaXJlKCkgb3IgdXBkYXRlKCkgY2FsbHMuXG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAvLz0+IElmIHRoZSBmaWx0ZXJpbmcgbG9naWMgYmVjb21lcyBtb3JlIGNvbXBsZXggaGVyZSwgd2UgY2FuIHVzZSBTd2FsLmlzVmFsaWRQYXJhbWV0ZXJcbiAgICAgICAgICAgIC5maWx0ZXIoKHByb3ApOiBwcm9wIGlzIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zID0+ICFwcm9wLnN0YXJ0c1dpdGgoJ3N3YWwnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuXG4gICAgICAgIC8vPT4gRXZlbnR1YWxseSB0cmlnZ2VyIHJlLXJlbmRlciBpZiB0aGUgbW9kYWwgaXMgb3Blbi5cbiAgICAgICAgdm9pZCB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQ2xvc2VzIHRoZSBTd2VldEFsZXJ0IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLz0+IFJlbGVhc2UgdGhlIG1vZGFsIGlmIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGFuZCBpZiB0aGF0IGJlaGF2aW91ciBpcyBub3QgZGlzYWJsZWQuXG4gICAgICAgIGNvbnN0IGRpc21pc3NPbkRlc3Ryb3kgPSB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3lcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRGlzbWlzc09uRGVzdHJveTtcblxuICAgICAgICBkaXNtaXNzT25EZXN0cm95ICYmIHRoaXMuZGlzbWlzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBTd2VldEFsZXJ0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgU3dlZXRBbGVydDIgcHJvbWlzZSBmb3IgY29udmVuaWVuY2UgYW5kIHVzZSBpbiBjb2RlIGJlaGluZCB0ZW1wbGF0ZXMuXG4gICAgICogT3RoZXJ3aXNlLCAoY29uZmlybSk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGFuZCAoY2FuY2VsKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgY2FuIGJlIHVzZWQgaW4gdGVtcGxhdGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBmaXJlKCk6IFByb21pc2U8U3dlZXRBbGVydFJlc3VsdD4ge1xuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuXG4gICAgICAgIC8vPT4gQnVpbGQgdGhlIFN3ZWV0QWxlcnQyIG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLz0+IE1lcmdlIHdpdGggY2FsY3VsYXRlZCBvcHRpb25zIHNldCBmb3IgdGhhdCBzcGVjaWZpYyBzd2FsXG4gICAgICAgICAgICAuLi50aGlzLnN3YWxPcHRpb25zLFxuXG4gICAgICAgICAgICAvLz0+IEhhbmRsZSBtb2RhbCBsaWZlY3ljbGUgZXZlbnRzXG4gICAgICAgICAgICBvbkJlZm9yZU9wZW46IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJlZm9yZU9wZW4uZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9wZW46IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVuZGVyOiAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlOiAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZS5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJDbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95LmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhIEFuZCB3YWl0IGZvciBjb25maXJtYXRpb24gb3IgZGltaXNzYWwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN3YWwuZmlyZShvcHRpb25zKTtcblxuICAgICAgICAvLz0+IEVtaXQgb24gKGNvbmZpcm0pIG9yIChjYW5jZWwpXG4gICAgICAgIGlmICgndmFsdWUnIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtLmVtaXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQocmVzdWx0LmRpc21pc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBpZiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2YWx1ZSB0aGF0IHRoZSBtb2RhbCB3aWxsIHJlc29sdmUgd2l0aCwgdHJpZ2dlcmluZyBlaXRoZXIgKGNvbmZpcm0pIG9yIChjYW5jZWwpLlxuICAgICAqICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIChkaW1pc3MpIHdpbGwgZW1pdCBgdW5kZWZpbmVkYC5cbiAgICAgKiAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgU3dhbC5jbG9zZX1cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZGlzbWlzcyhyZXN1bHQ/OiBTd2VldEFsZXJ0UmVzdWx0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcbiAgICAgICAgc3dhbC5jbG9zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgU3dlZXRBbGVydDIgb3B0aW9ucyB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLCBjYXVzaW5nIHRoZSBtb2RhbCB0byByZS1yZW5kZXIuXG4gICAgICogSWYgdGhlIG1vZGFsIGlzIG5vdCBvcGVuZWQsIHRoZSBjb21wb25lbnQgb3B0aW9ucyB3aWxsIHNpbXBseSBiZSB1cGRhdGVkIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgbm90IGFsbCBTd2VldEFsZXJ0MiBvcHRpb25zIGFyZSB1cGRhdGFibGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZShvcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuICAgICAgICBjb25zdCBhbGxPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICBjb25zdCB1cGRhdGFibGVPcHRpb25zID0gT2JqZWN0LmtleXMoYWxsT3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSk6IGtleSBpcyBrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucyA9PiBzd2FsLmlzVXBkYXRhYmxlUGFyYW1ldGVyKGtleSkpXG4gICAgICAgICAgICAucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gYWxsT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSBhcyB7IFtQIGluIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zXTogYW55IH0pO1xuXG4gICAgICAgIHN3YWwudXBkYXRlKHVwZGF0YWJsZU9wdGlvbnMpO1xuICAgIH1cbn1cbiJdfQ==